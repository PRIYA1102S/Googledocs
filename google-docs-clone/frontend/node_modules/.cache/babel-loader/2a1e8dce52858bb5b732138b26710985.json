{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback } from 'react';\nimport { updateDocument } from '../services/documentService';\nconst useAutoSave = (documentId, document, enabled = true, onSaveSuccess = null) => {\n  _s();\n  const timeoutRef = useRef(null);\n  const lastSavedRef = useRef(null);\n  const [isSaving, setIsSaving] = useState(false);\n  const saveDocument = useCallback(async () => {\n    if (!documentId || !document || isSaving) {\n      return;\n    }\n\n    // Check if document has actually changed\n    const currentDocString = JSON.stringify(document);\n    if (lastSavedRef.current === currentDocString) {\n      return;\n    }\n\n    // Prevent saving obviously invalid payloads\n    if (!document.title || document.title.trim() === '') {\n      return;\n    }\n    try {\n      setIsSaving(true);\n      // Don't use the returned document to avoid state updates that could reset cursor\n      await updateDocument(documentId, document);\n      lastSavedRef.current = currentDocString;\n      console.log('Document auto-saved successfully');\n\n      // Call the success callback if provided\n      if (onSaveSuccess) {\n        console.log('Auto-save completed successfully, calling success callback');\n        onSaveSuccess();\n      }\n    } catch (error) {\n      console.error('Auto-save failed:', error);\n    } finally {\n      setIsSaving(false);\n    }\n  }, [documentId, document, onSaveSuccess]);\n  const debouncedSave = useCallback(() => {\n    if (!enabled) return;\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    timeoutRef.current = setTimeout(() => {\n      saveDocument();\n    }, 2000); // Auto-save after 2 seconds of inactivity\n  }, [saveDocument, enabled]);\n  useEffect(() => {\n    if (enabled && document) {\n      debouncedSave();\n    }\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, [document, debouncedSave, enabled]);\n\n  // Cleanup timers on unmount; do not trigger a save to avoid state update after unmount warnings\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n  const forceSave = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    return saveDocument();\n  }, [saveDocument]);\n  return {\n    forceSave,\n    isSaving: isSavingRef.current\n  };\n};\n_s(useAutoSave, \"GZqYqCqDBCGRD/+tEDufHyGCYKg=\");\nexport default useAutoSave;","map":{"version":3,"names":["useEffect","useRef","useCallback","updateDocument","useAutoSave","documentId","document","enabled","onSaveSuccess","_s","timeoutRef","lastSavedRef","isSaving","setIsSaving","useState","saveDocument","currentDocString","JSON","stringify","current","title","trim","console","log","error","debouncedSave","clearTimeout","setTimeout","forceSave","isSavingRef"],"sources":["D:/Docs-MERN/google-docs-clone/frontend/src/hooks/useAutoSave.js"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\r\nimport { updateDocument } from '../services/documentService';\r\n\r\nconst useAutoSave = (documentId, document, enabled = true, onSaveSuccess = null) => {\r\n  const timeoutRef = useRef(null);\r\n  const lastSavedRef = useRef(null);\r\n  const [isSaving, setIsSaving] = useState(false);\r\n\r\n  const saveDocument = useCallback(async () => {\r\n    if (!documentId || !document || isSaving) {\r\n      return;\r\n    }\r\n\r\n    // Check if document has actually changed\r\n    const currentDocString = JSON.stringify(document);\r\n    if (lastSavedRef.current === currentDocString) {\r\n      return;\r\n    }\r\n\r\n    // Prevent saving obviously invalid payloads\r\n    if (!document.title || document.title.trim() === '') {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsSaving(true);\r\n      // Don't use the returned document to avoid state updates that could reset cursor\r\n      await updateDocument(documentId, document);\r\n      lastSavedRef.current = currentDocString;\r\n      console.log('Document auto-saved successfully');\r\n      \r\n      // Call the success callback if provided\r\n      if (onSaveSuccess) {\r\n        console.log('Auto-save completed successfully, calling success callback');\r\n        onSaveSuccess();\r\n      }\r\n    } catch (error) {\r\n      console.error('Auto-save failed:', error);\r\n    } finally {\r\n      setIsSaving(false);\r\n    }\r\n  }, [documentId, document, onSaveSuccess]);\r\n\r\n  const debouncedSave = useCallback(() => {\r\n    if (!enabled) return;\r\n\r\n    if (timeoutRef.current) {\r\n      clearTimeout(timeoutRef.current);\r\n    }\r\n\r\n    timeoutRef.current = setTimeout(() => {\r\n      saveDocument();\r\n    }, 2000); // Auto-save after 2 seconds of inactivity\r\n  }, [saveDocument, enabled]);\r\n\r\n  useEffect(() => {\r\n    if (enabled && document) {\r\n      debouncedSave();\r\n    }\r\n\r\n    return () => {\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n      }\r\n    };\r\n  }, [document, debouncedSave, enabled]);\r\n\r\n  // Cleanup timers on unmount; do not trigger a save to avoid state update after unmount warnings\r\n  useEffect(() => {\r\n    return () => {\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const forceSave = useCallback(() => {\r\n    if (timeoutRef.current) {\r\n      clearTimeout(timeoutRef.current);\r\n    }\r\n    return saveDocument();\r\n  }, [saveDocument]);\r\n\r\n  return {\r\n    forceSave,\r\n    isSaving: isSavingRef.current\r\n  };\r\n};\r\n\r\nexport default useAutoSave;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}